#######################################################################
# Test for copying block of size 63;
#######################################################################
	.pos 0
main:	irmovq Stack, %rsp  	# Set up stack pointer

	# Set up arguments for copy function and then invoke it
	irmovq $63, %rdx		# src and dst have 63 elements
	irmovq dest, %rsi	# dst array
	irmovq src, %rdi	# src array
    # corrupt all the unused registers to prevent assumptions
    irmovq $0x5710331, %rax
    irmovq $0x5710331, %rbx
    irmovq $0x5710331, %rcx
    irmovq $0x5710331, %rbp
    irmovq $0x5710331, %r8
    irmovq $0x5710331, %r9
    irmovq $0x5710331, %r10
    irmovq $0x5710331, %r11
    irmovq $0x5710331, %r12
    irmovq $0x5710331, %r13
    irmovq $0x5710331, %r14
	call abscopy		 
	halt			# should halt with abs sum in %rax
StartFun:
#/* $begin abscopy-ys */
##################################################################
# abscopy.ys - copy the absolute values of a src block of n words to dst.
# Return the sum of copied (absolute) values.
#
# name: Emre Ge√ßit
# id: 2521581


##################################################################
# Do not modify this portion
# Function prologue.
# %rdi = src, %rsi = dst, %rdx = n
abscopy:
##################################################################
# You can modify this portion
        irmovq $1, %r11         # %r11 = 1, will be used inside the loop
        irmovq $8, %r8          # %r8 = 8, will be used inside the loop
irmovq $16, %rcx
        # Loop header
        xorq %rax,%rax          # sum = 0;
Check:
        subq %rcx, %rdx         # %rdx -= %rcx
        jl Remaining            # if n < AC, goto Remaining

Loop1:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive1           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive1:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
Loop2:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive2           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive2:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
Loop3:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive3           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive3:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
Loop4:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive4           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive4:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
Loop5:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive5           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive5:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
Loop6:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive6           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive6:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
Loop7:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive7           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive7:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
Loop8:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive8           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive8:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
Loop9:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive9           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive9:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
Loop10:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive10           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive10:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
Loop11:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive11           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive11:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
Loop12:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive12           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive12:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
Loop13:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive13           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive13:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
Loop14:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive14           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive14:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
Loop15:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive15           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive15:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
Loop16:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive16           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive16:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++

        jmp Check               # goto Check

Remaining:
        addq %rcx, %rdx         # %rdx += %rcx
Loop:
        je Done                # if n == 0, goto Done
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive            # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
        subq %r11, %rdx         # n--
        andq %rdx, %rdx         # n > 0?
        jg Loop                 # if so, goto Loop:
        
##################################################################
# Do not modify the following section of code
# Function epilogue.
Done:
        ret
##################################################################
# Keep the following label at the end of your function
End:
#/* $end abscopy-ys */
EndFun:

###############################
# Source and destination blocks 
###############################
	.align 8
src:
	.quad 1
	.quad -2
	.quad -3
	.quad 4
	.quad -5
	.quad 6
	.quad 7
	.quad -8
	.quad 9
	.quad -10
	.quad 11
	.quad -12
	.quad -13
	.quad -14
	.quad -15
	.quad -16
	.quad 17
	.quad 18
	.quad 19
	.quad 20
	.quad -21
	.quad -22
	.quad -23
	.quad -24
	.quad -25
	.quad -26
	.quad 27
	.quad -28
	.quad 29
	.quad -30
	.quad -31
	.quad 32
	.quad -33
	.quad 34
	.quad -35
	.quad -36
	.quad -37
	.quad 38
	.quad 39
	.quad 40
	.quad -41
	.quad -42
	.quad 43
	.quad 44
	.quad -45
	.quad 46
	.quad 47
	.quad -48
	.quad -49
	.quad -50
	.quad -51
	.quad -52
	.quad -53
	.quad 54
	.quad 55
	.quad 56
	.quad 57
	.quad 58
	.quad 59
	.quad 60
	.quad 61
	.quad 62
	.quad 63
	.quad 0xbcdefa # This shouldn't get moved

	.align 16
Predest:
	.quad 0xbcdefa
dest:
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
Postdest:
	.quad 0xdefabc

.align 8
# Run time stack
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0

Stack:
