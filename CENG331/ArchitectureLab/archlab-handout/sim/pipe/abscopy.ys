#/* $begin abscopy-ys */
##################################################################
# abscopy.ys - copy the absolute values of a src block of n words to dst.
# Return the sum of copied (absolute) values.
#
# name: Emre Ge√ßit
# id: 2521581
# I have tried different configurations for loop count.
# Best performance is achieved with 5 loops.

##################################################################
# Do not modify this portion
# Function prologue.
# %rdi = src, %rsi = dst, %rdx = n
abscopy:
##################################################################
# You can modify this portion
        irmovq $1, %r11         # %r11 = 1, will be used inside the loop
        irmovq $8, %r8          # %r8 = 8, will be used inside the loop
        irmovq $48, %r9
irmovq $6, %rcx
        # Loop header
        xorq %rax,%rax          # sum = 0;
Check:
        subq %rcx, %rdx         # %rdx -= %rcx
        jl Remaining            # if n < AC, goto Remaining

Loop1:
        mrmovq 0(%rdi), %r10     # read val from src...
        xorq %r12, %r12         # %r12 = 0
        subq %r10, %r12         # %r12 = -%r10
        cmovg %r12, %r10        # if %r12 > 0, %r10 = -%r10 
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, 0(%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
Loop2:
        mrmovq 8(%rdi), %r10     # read val from src...
        xorq %r12, %r12         # %r12 = 0
        subq %r10, %r12         # %r12 = -%r10
        cmovg %r12, %r10        # if %r12 > 0, %r10 = -%r10 
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, 8(%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
Loop3:
        mrmovq 16(%rdi), %r10     # read val from src...
        xorq %r12, %r12         # %r12 = 0
        subq %r10, %r12         # %r12 = -%r10
        cmovg %r12, %r10        # if %r12 > 0, %r10 = -%r10 
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, 16(%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
Loop4:
        mrmovq 24(%rdi), %r10     # read val from src...
        xorq %r12, %r12         # %r12 = 0
        subq %r10, %r12         # %r12 = -%r10
        cmovg %r12, %r10        # if %r12 > 0, %r10 = -%r10 
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, 24(%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
Loop5:
        mrmovq 32(%rdi), %r10     # read val from src...
        xorq %r12, %r12         # %r12 = 0
        subq %r10, %r12         # %r12 = -%r10
        cmovg %r12, %r10        # if %r12 > 0, %r10 = -%r10 
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, 32(%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
Loop6:
        mrmovq 40(%rdi), %r10     # read val from src...
        xorq %r12, %r12         # %r12 = 0
        subq %r10, %r12         # %r12 = -%r10
        cmovg %r12, %r10        # if %r12 > 0, %r10 = -%r10 
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, 40(%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.

        addq %r9, %rdi          # src += AC*8
        addq %r9, %rsi          # dst += AC*8
        jmp Check               # goto Check

Remaining:
        addq %rcx, %rdx         # %rdx += %rcx
Loop:
        je Done                # if n == 0, goto Done
        mrmovq (%rdi), %r10     # read val from src...
        xorq %r12, %r12         # %r12 = 0
        subq %r10, %r12         # %r12 = -%r10
        cmovg %r12, %r10        # if %r12 > 0, %r10 = -%r10 
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
        subq %r11, %rdx         # n--
        andq %rdx, %rdx         # n > 0?
        jg Loop                 # if so, goto Loop:
        
##################################################################
# Do not modify the following section of code
# Function epilogue.
Done:
        ret
##################################################################
# Keep the following label at the end of your function
End:
#/* $end abscopy-ys */
