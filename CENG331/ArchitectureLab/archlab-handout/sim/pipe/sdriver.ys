#######################################################################
# Test for copying block of size 4;
#######################################################################
	.pos 0
main:	irmovq Stack, %rsp  	# Set up stack pointer

	# Set up arguments for copy function and then invoke it
	irmovq $4, %rdx		# src and dst have 4 elements
	irmovq dest, %rsi	# dst array
	irmovq src, %rdi	# src array
    # corrupt all the unused registers to prevent assumptions
    irmovq $0x5710331, %rax
    irmovq $0x5710331, %rbx
    irmovq $0x5710331, %rcx
    irmovq $0x5710331, %rbp
    irmovq $0x5710331, %r8
    irmovq $0x5710331, %r9
    irmovq $0x5710331, %r10
    irmovq $0x5710331, %r11
    irmovq $0x5710331, %r12
    irmovq $0x5710331, %r13
    irmovq $0x5710331, %r14
	call abscopy		 
	halt			# should halt with abs sum in %rax
StartFun:
#/* $begin abscopy-ys */
##################################################################
# abscopy.ys - copy the absolute values of a src block of n words to dst.
# Return the sum of copied (absolute) values.
#
# name: Emre Ge√ßit
# id: 2521581


##################################################################
# Do not modify this portion
# Function prologue.
# %rdi = src, %rsi = dst, %rdx = n
abscopy:
##################################################################
# You can modify this portion
        irmovq $1, %r11         # %r11 = 1, will be used inside the loop
        irmovq $8, %r8          # %r8 = 8, will be used inside the loop
irmovq $16, %rcx
        # Loop header
        xorq %rax,%rax          # sum = 0;
Check:
        subq %rcx, %rdx         # %rdx -= %rcx
        jl Remaining            # if n < AC, goto Remaining

Loop1:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive1           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive1:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
Loop2:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive2           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive2:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
Loop3:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive3           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive3:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
Loop4:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive4           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive4:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
Loop5:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive5           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive5:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
Loop6:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive6           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive6:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
Loop7:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive7           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive7:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
Loop8:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive8           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive8:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
Loop9:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive9           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive9:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
Loop10:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive10           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive10:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
Loop11:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive11           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive11:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
Loop12:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive12           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive12:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
Loop13:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive13           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive13:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
Loop14:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive14           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive14:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
Loop15:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive15           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive15:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
Loop16:
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive16           # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive16:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++

        jmp Check               # goto Check

Remaining:
        addq %rcx, %rdx         # %rdx += %rcx
Loop:
        je Done                # if n == 0, goto Done
        mrmovq (%rdi), %r10     # read val from src...
        andq %r10, %r10         # val >= 0?
        jge Positive            # if so, skip negating
        isubq $0, %r10          # Use isubq to negate val
Positive:
        addq %r10, %rax         # sum += absval   
        rmmovq %r10, (%rsi)     # ...and store it to dst
        # irmovq $1, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r11 is used.
        # irmovq $8, %r10 | This costs an extra cycle each loop and unnecessary. Instead dedicated register %r8 is used.
        addq %r8, %rsi          # dst++
        addq %r8, %rdi          # src++
        subq %r11, %rdx         # n--
        andq %rdx, %rdx         # n > 0?
        jg Loop                 # if so, goto Loop:
        
##################################################################
# Do not modify the following section of code
# Function epilogue.
Done:
        ret
##################################################################
# Keep the following label at the end of your function
End:
#/* $end abscopy-ys */
EndFun:

###############################
# Source and destination blocks 
###############################
	.align 8
src:
	.quad 1
	.quad 2
	.quad -3
	.quad -4
	.quad 0xbcdefa # This shouldn't get moved

	.align 16
Predest:
	.quad 0xbcdefa
dest:
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
Postdest:
	.quad 0xdefabc

.align 8
# Run time stack
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0

Stack:
